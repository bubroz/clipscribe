# Implementation Research: curl-cffi + yt-dlp Integration

**Date:** September 30, 2025  
**Status:** Research Phase Complete  
**Next:** Implementation

---

## Key Findings

### 1. yt-dlp Has Built-in Impersonation Support ✅

**Discovery**: yt-dlp v2025.8.27 (our current version) already has `--impersonate` flag

```bash
$ poetry run yt-dlp --help | grep impersonate
    --impersonate CLIENT[:OS]       Client to impersonate for requests
    --list-impersonate-targets      List available clients to impersonate
```

**Available Targets** (requires curl-cffi):
- Chrome (all OS)
- Firefox (all OS) 
- Safari (all OS)
- Edge (all OS)
- Tor

**Current Status**: All targets show "(unavailable)" because curl-cffi is not installed.

---

### 2. curl-cffi Integration is Simple

**Installation**:
```bash
poetry add curl-cffi
```

**Auto-Detection**: yt-dlp automatically detects and uses curl-cffi when installed. No code changes needed!

**Usage**:
```bash
# After installing curl-cffi, this will work:
yt-dlp --impersonate chrome:windows "https://vimeo.com/148751763"
```

---

### 3. Version Requirements

| Component | Current | Latest | Required For |
|-----------|---------|--------|--------------|
| yt-dlp | 2025.8.27 | 2025.09.26+ | Native SABR support |
| curl-cffi | Not installed | 0.11+ | TLS impersonation |
| Python | 3.12 | 3.12 | Compatible ✅ |

**Action**: Update yt-dlp, install curl-cffi

---

### 4. YouTube PO Token Research

**What is a PO Token?**
- "Proof of Origin" token generated by YouTube's JavaScript
- Required for SABR-protected content
- Format: `web.gvs+{base64_string}`
- Lifespan: ~6 hours
- Extracted alongside `visitor_data` cookie

**Extraction Methods**:

#### Manual (Current Workaround):
```bash
# 1. Open embed page: https://www.youtube.com/embed/{video_id}
# 2. Open DevTools → Application → Cookies
# 3. Copy __Secure-YEC → Extract po_token
# 4. Copy VISITOR_INFO1_LIVE → visitor_data
```

#### Automated Options:
1. **yt-dlp native** (latest versions have partial support)
2. **yt-dlp-pot-provider** plugin (GitHub)
3. **BgUtils** browser extension
4. **Custom Selenium script** (lightweight, no full browser needed)

**Usage with yt-dlp**:
```bash
yt-dlp \
  --extractor-args "youtube:po_token=web.gvs+XXX;visitor_data=YYY" \
  "https://youtube.com/watch?v=..."
```

---

### 5. Recent yt-dlp Improvements (2025.09.26)

**Changelog Research** (from consultant):
- Native SABR protocol support added
- Prioritizes HTTPS formats
- Falls back to SABR with PO tokens
- Improved nsig extraction

**Recommendation**: Update to latest version for best YouTube support.

---

## Implementation Strategy

### Phase 1: Basic Impersonation (Vimeo Fix) - 1 Hour

**Goal**: Test if curl-cffi solves Vimeo TLS fingerprinting

**Steps**:
1. Install curl-cffi: `poetry add curl-cffi`
2. Verify yt-dlp detects it: `yt-dlp --list-impersonate-targets`
3. Test Vimeo download: `yt-dlp --impersonate chrome "https://vimeo.com/148751763"`
4. If successful: Integrate into UniversalVideoClient

**Expected Result**: Vimeo downloads work immediately

**Fallback**: If this fails, TLS fingerprinting is more sophisticated than expected

---

### Phase 2: YouTube PO Tokens - 2-4 Hours

**Goal**: Implement automated PO token extraction for YouTube

**Option A: Try Native yt-dlp First** (quickest)
```bash
# Update yt-dlp
poetry update yt-dlp

# Test if native SABR support works
yt-dlp "https://youtube.com/watch?v=5Fy2y3vzkWE"
```

**Option B: Lightweight Selenium Extractor** (if native fails)
```python
from playwright.async_api import async_playwright

async def extract_po_token(video_id: str) -> dict:
    """Extract PO token from YouTube embed page."""
    async with async_playwright() as p:
        browser = await p.chromium.launch(headless=True)
        page = await browser.new_page()
        
        # Load embed page (lightweight, no full video)
        await page.goto(f"https://www.youtube.com/embed/{video_id}")
        
        # Extract tokens from cookies
        cookies = await page.context.cookies()
        po_token = None
        visitor_data = None
        
        for cookie in cookies:
            if cookie['name'] == '__Secure-YEC':
                # Parse po_token from cookie value
                po_token = extract_po_from_cookie(cookie['value'])
            elif cookie['name'] == 'VISITOR_INFO1_LIVE':
                visitor_data = cookie['value']
        
        await browser.close()
        return {"po_token": po_token, "visitor_data": visitor_data}
```

**Option C: Use Existing Plugin** (if available)
- Research yt-dlp-pot-provider on GitHub
- Check compatibility with our version
- Integrate as dependency

---

### Phase 3: Hybrid Downloader Architecture - 4-8 Hours

**Goal**: Build smart downloader with fallback strategy

```python
class SmartVideoDownloader:
    """
    Intelligent video downloader with multiple fallback strategies.
    
    Strategy:
    1. Try impersonation (curl-cffi) - fastest
    2. If blocked, try browser automation - robust
    3. Exponential backoff on failures
    """
    
    async def download(self, url: str, output_dir: str) -> tuple[str, dict]:
        """Download video with intelligent fallback."""
        
        # Strategy 1: Impersonation (fast path)
        try:
            return await self._download_with_impersonation(url, output_dir)
        except (BlockedError, TLSFingerprintError) as e:
            logger.warning(f"Impersonation failed: {e}, falling back to browser")
        
        # Strategy 2: Browser automation (fallback)
        try:
            return await self._download_with_browser(url, output_dir)
        except Exception as e:
            logger.error(f"All download strategies failed: {e}")
            raise
    
    async def _download_with_impersonation(
        self, url: str, output_dir: str
    ) -> tuple[str, dict]:
        """Fast path: yt-dlp with curl-cffi impersonation."""
        
        opts = self.base_opts.copy()
        opts['outtmpl'] = os.path.join(output_dir, "%(title)s-%(id)s.%(ext)s")
        
        # Add impersonation
        opts['impersonate'] = 'chrome:windows'  # or 'firefox', 'safari'
        
        # Add PO token for YouTube
        if self._is_youtube(url):
            po_data = await self._get_po_token(url)
            if po_data:
                opts['extractor_args'] = {
                    'youtube': [
                        f"po_token={po_data['po_token']}",
                        f"visitor_data={po_data['visitor_data']}"
                    ]
                }
        
        # Download with yt-dlp
        with yt_dlp.YoutubeDL(opts) as ydl:
            info = ydl.extract_info(url, download=False)
            ydl.download([url])
            audio_file = self._find_audio_file(output_dir, info['id'])
            metadata = self._create_metadata(info)
            return audio_file, metadata
    
    async def _download_with_browser(
        self, url: str, output_dir: str
    ) -> tuple[str, dict]:
        """Fallback: Playwright browser automation."""
        
        async with async_playwright() as p:
            browser = await p.chromium.launch(headless=True)
            page = await browser.new_page()
            
            # Navigate to video
            await page.goto(url)
            
            # Wait for video to be ready
            await page.wait_for_selector('video')
            
            # Extract video URL from page
            video_url = await page.evaluate(
                """() => {
                    const video = document.querySelector('video');
                    return video ? video.src : null;
                }"""
            )
            
            if not video_url:
                raise ValueError("Could not extract video URL")
            
            # Download via requests or yt-dlp with extracted URL
            # ... implementation ...
            
            await browser.close()
            return audio_file, metadata
```

---

### Phase 4: Testing & Validation - 2-4 Hours

**Test Matrix**:

| Platform | Method | Expected Result |
|----------|--------|-----------------|
| Vimeo | Impersonation | ✅ Works |
| YouTube (public) | Impersonation + PO | ✅ Works |
| YouTube (SABR) | Impersonation + PO | ✅ Works |
| TikTok | Impersonation | ❓ Test |
| Twitter/X | Impersonation | ❓ Test |

**Validation**:
```bash
# Test each platform
poetry run python test_smart_downloader.py

# Expected:
# - Vimeo: Fast path succeeds
# - YouTube: Fast path succeeds (with PO token)
# - All: Fallback works if fast path fails
```

---

## Risk Assessment

### Low Risk ✅
- **curl-cffi installation**: Mature library, well-maintained
- **yt-dlp integration**: Built-in support, auto-detection
- **Vimeo**: Should work immediately

### Medium Risk ⚠️
- **YouTube PO tokens**: May need automation, 6-hour rotation
- **Browser fallback**: Memory overhead, complexity
- **Platform evolution**: Detection methods change over time

### Mitigation Strategies
1. **Monitor success rates**: Track which method works per platform
2. **Quarterly updates**: Update curl-cffi, yt-dlp, browser versions
3. **Exponential backoff**: Don't hammer blocked endpoints
4. **User notifications**: Alert on persistent failures

---

## Cost Analysis

**Impersonation Path** (curl-cffi):
- Infrastructure: $0 (no additional servers)
- API costs: $0 (no proxies)
- Processing: Same as before ($0.214/video)
- **Total**: $0.214/video ✅ (within target after Grok optimization)

**Browser Fallback**:
- Memory: 100-500MB per instance
- CPU: Negligible for headless
- Infrastructure: ~$5-10/month for VPS if scaling
- **Total**: Still $0.214/video + infrastructure

**Compared to Proxies** (rejected):
- Residential proxies: $3-15/GB
- Average video: 50MB
- Cost: $0.15-0.75/video ❌
- **Total**: 3-15x over budget

**Winner**: Impersonation + Browser fallback is cost-effective.

---

## Timeline

| Phase | Duration | Deliverable |
|-------|----------|-------------|
| **Phase 1** | 1 hour | curl-cffi installed, Vimeo working |
| **Phase 2** | 2-4 hours | YouTube PO tokens automated |
| **Phase 3** | 4-8 hours | Hybrid downloader implemented |
| **Phase 4** | 2-4 hours | Full test suite passing |
| **TOTAL** | 9-17 hours | Production-ready download system |

**Estimated Completion**: 2-3 days (with testing and documentation)

---

## Next Actions

1. ✅ Research complete - this document
2. ⏭️ Install curl-cffi and test Vimeo (Phase 1)
3. ⏭️ Update yt-dlp and test YouTube (Phase 2)
4. ⏭️ Build hybrid downloader (Phase 3)
5. ⏭️ Full integration testing (Phase 4)

---

## Questions Answered

**Q: Is curl-cffi effective in 2025?**  
A: Yes, yt-dlp has built-in support and consultant confirmed 80%+ success rate.

**Q: How complex is PO token automation?**  
A: Moderate - can try native yt-dlp first, lightweight Selenium if needed.

**Q: Should we use browser automation first?**  
A: No - impersonation is faster, lighter. Browser is fallback only.

**Q: What's the longevity?**  
A: 6-12 months for impersonation, 1-2 years for browser. Hybrid: 2+ years.

---

**Ready to proceed with Phase 1 implementation.**
