---
description: Consistent error handling and logging patterns throughout ClipScribe
globs: 
alwaysApply: false
---
---
description: "Consistent error handling and logging patterns throughout ClipScribe"
globs: ["**/*.py"]
alwaysApply: false
---

# Error Handling & Logging Patterns

## Logging Setup

ClipScribe uses loguru for advanced logging with Rich integration:

```python
import logging
from loguru import logger

# Module-level logger
logger = logging.getLogger(__name__)
```

## Error Handling Patterns

### Basic Try-Except Pattern
```python
try:
    result = await process_video(url)
except TranscriptNotAvailable:
    logger.warning("No transcript available, falling back to audio transcription")
    result = await transcribe_audio(url)
except Exception as e:
    logger.error(f"Failed to process video: {e}")
    raise VideoProcessingError(f"Unable to process video: {e}")
```

### Graceful Degradation
```python
try:
    # Try advanced extraction
    entities = await advanced_extractor.extract(text)
except Exception as e:
    logger.warning(f"Advanced extraction failed: {e}, falling back to basic")
    try:
        entities = basic_extractor.extract(text)
    except Exception as e2:
        logger.error(f"All extraction methods failed: {e2}")
        return {"entities": [], "error": str(e2)}
```

### Model Loading Pattern
```python
try:
    self.model = load_model(model_name)
    logger.info(f"Loaded model: {model_name}")
except OSError:
    logger.warning(f"Model {model_name} not found. Installing...")
    install_model(model_name)
    self.model = load_model(model_name)
except Exception as e:
    logger.error(f"Failed to load model: {e}")
    raise
```

## Logging Levels

### Info - Normal operations
```python
logger.info(f"Processing video: {url}")
logger.info(f"Saved {len(entities)} entities to {output_path}")
```

### Warning - Recoverable issues
```python
logger.warning("No entities found by SpaCy, falling back to LLM")
logger.warning(f"GLiNER extraction warning (non-critical): {e}")
```

### Error - Failures needing attention
```python
logger.error(f"Failed to process video: {e}")
logger.exception("Transcription failed")  # Includes traceback
```

### Debug - Development info
```python
logger.debug(f"Cache key: {cache_key}")
logger.debug(f"Processing stats: {stats}")
```

## Custom Exceptions

Define domain-specific exceptions:
```python
class VideoProcessingError(Exception):
    """Raised when video processing fails."""
    pass

class TranscriptNotAvailable(Exception):
    """Raised when no transcript can be obtained."""
    pass

class ModelLoadError(Exception):
    """Raised when AI model fails to load."""
    pass
```

## Error Context

Always provide context in error messages:
```python
# Bad
raise Exception("Failed")

# Good
raise VideoProcessingError(
    f"Failed to process video '{video_id}' from {platform}: {original_error}"
)
```

## Async Error Handling

For async operations with multiple tasks:
```python
results = await asyncio.gather(*tasks, return_exceptions=True)

for i, result in enumerate(results):
    if isinstance(result, Exception):
        logger.error(f"Task {i} failed: {result}")
    else:
        process_result(result)
```

## Cost-Aware Error Handling

Track costs even on failure:
```python
try:
    result = await expensive_operation()
    self.total_cost += result.cost
except Exception as e:
    # Still track partial costs
    self.total_cost += estimate_partial_cost()
    logger.error(f"Operation failed after ${self.total_cost:.4f}: {e}")
    raise
```

## User-Friendly Error Messages

In CLI commands:
```python
try:
    result = await operation()
except KeyboardInterrupt:
    console.print("\n[yellow]Operation cancelled by user[/yellow]")
    sys.exit(1)
except VideoProcessingError as e:
    console.print(f"[red]Video Error: {e}[/red]")
    console.print("[dim]Try a different URL or check your connection[/dim]")
    sys.exit(1)
except Exception as e:
    logger.exception("Unexpected error")
    console.print(f"[red]Unexpected error: {e}[/red]")
    console.print("[dim]Please report this issue[/dim]")
    sys.exit(1)
```

## Performance Logging

Log operation times:
```python
import time

start_time = time.time()
try:
    result = await operation()
finally:
    elapsed = time.time() - start_time
    logger.info(f"Operation completed in {elapsed:.2f}s")
```
