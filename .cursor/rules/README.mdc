---
description: 
globs: 
alwaysApply: true
---
---
description: "Master rule governing all other rules and task completion"
globs: []
alwaysApply: true
---

# Master Rules & Task Completion Guide

This is the central rule that governs all other rules and ensures proper task completion in the ClipScribe project.

## Rule Management

### Rule Format
Each `.mdc` file in `.cursor/rules/` follows this structure:

```yaml
---
description: "Brief description of the rule's purpose"
globs: ["**/*.py", "src/**/*.ts"]  # File patterns for auto-attachment
alwaysApply: false  # Whether the rule always applies
---

# Rule Content
```

### Available Rules (17 total, consolidated from 20)

**Core Rules:**
- `README.mdc` (this file) - Master rule governing all others, includes CONTINUATION_PROMPT format
- `core-identity.mdc` - Project mission and fundamental principles 
- `clipscribe-architecture.mdc` - Core architecture and design patterns
- `file-organization.mdc` - File placement and project structure

**Development Patterns:**
- `api-patterns.mdc` - API integration with cost optimization (merged from 2 rules)
- `async-patterns.mdc` - Best practices for async/await code
- `model-data-structures.mdc` - Pydantic models and data validation
- `configuration-management.mdc` - Settings and configuration guidelines
- `error-handling-logging.mdc` - Consistent error handling and logging

**Component-Specific:**
- `video-processing.mdc` - Guidelines for video/audio processing code
- `extractor-patterns.mdc` - Best practices for knowledge extractors
- `cli-command-patterns.mdc` - Patterns and conventions for CLI commands
- `output-format-management.mdc` - Managing and adding output formats
- `visualization-diagrams.mdc` - Knowledge graph visualization

**Quality & Process:**
- `documentation.mdc` - Documentation standards and update triggers (merged from 2 rules)
- `testing-standards.mdc` - Testing requirements with validation protocols
- `troubleshooting-guide.mdc` - Common debugging patterns (condensed)

### How Rules Work
1. **Auto-attachment**: Rules with matching `globs` patterns automatically apply when working on those files
2. **Always Apply**: Rules with `alwaysApply: true` are active for all interactions
3. **Manual Reference**: You can reference any rule using `@rules/rule-name`

### Creating New Rules
When adding a new rule:
1. Use descriptive kebab-case filenames (e.g., `api-patterns.mdc`)
2. Include proper frontmatter with:
   - `description`: Brief explanation of what the rule covers
   - `globs`: File patterns where rule auto-applies (can be empty `[]`)
   - `alwaysApply`: true/false - whether rule is always active
3. Keep rules focused on a single concern
4. Include practical examples and code snippets
5. Use clear section headers and formatting
6. Add the rule to this README's Available Rules list

### When to Create Rules
Create a new rule when:
- You find yourself explaining the same pattern multiple times
- There's a specific convention unique to this project
- You want to document best practices for a component
- There are gotchas or non-obvious patterns to remember
- You need to ensure consistency across the codebase

### Updating Existing Rules
When modifying rules:
1. Preserve the frontmatter structure
2. Document why the change was made (in commit message)
3. Verify glob patterns still match intended files
4. Check for conflicts with other rules
5. Update any documentation that references the old behavior

## Task Completion Process

**CRITICAL: At the completion of EVERY task, follow the comprehensive communication and documentation update protocol.**

### Communication Template for Task Completion

**REQUIRED FORMAT: Combine real-time development narrative with comprehensive milestone documentation.**

#### Phase 1: Real-Time Development Narrative
During task execution, provide:
```markdown
**üéØ Development Order:**
1. **Component 1** (foundation/dependency reason)
2. **Component 2** (core functionality) 
3. **Component 3** (integration layer)

Let's start with **#1: Component Name** - explain why this is first.

[Show actual work being done with technical details]
- Read relevant files for context
- Implement specific changes with code snippets
- Explain technical decisions and architecture
- Document each step as it's completed

Perfect! Now I have Component 1 complete. Let's move to **#2: Component Name** - explain the dependency.

[Continue this pattern for each component]
```

#### Phase 2: Comprehensive Milestone Documentation
After completion, provide structured documentation:
```markdown
## ‚úÖ MAJOR MILESTONE ACHIEVED: [Task Name] Complete! üöÄ

### üéØ What Was Accomplished:

**1. Component Name** ‚úÖ
- Specific technical achievement 1
- Specific technical achievement 2  
- Performance/cost metrics if applicable

**2. Component Name** ‚úÖ
- Detailed implementation details
- Integration points and dependencies
- Quality improvements and optimizations

### üöÄ Key Achievements:
- **Architecture Impact**: How this changes the system
- **Performance Impact**: Metrics and improvements
- **Cost Impact**: Financial implications if relevant
- **User Impact**: How users benefit

### üìã Progress Status:
**‚úÖ COMPLETE** (X/Y components):
- List completed components

**üöß REMAINING** (Y-X components):
- List remaining work

### üìö Documentation Updates Completed:
- ‚úÖ **File 1**: What was updated and why
- ‚úÖ **File 2**: Specific changes made
- ‚úÖ **Version Control**: Commit and push status

### üöÄ Repository Status:
- ‚úÖ Local changes committed with conventional format
- ‚úÖ Remote repository synchronized  
- ‚úÖ Clean working tree

### üîÑ Next Steps/User Engagement:
Would you like me to proceed with [next logical component] to complete the [overall goal]?
```

#### Phase 3: Complete Task Checklist
**MANDATORY COMPLETION STEPS:**

1. **Documentation Updates** (see `documentation.mdc` for details)
   - [ ] CHANGELOG.md updated with current date
   - [ ] README.md updated if user-facing changes
   - [ ] CLI_REFERENCE.md updated if commands changed
   - [ ] Version files updated if releasing
   - [ ] CONTINUATION_PROMPT.md updated with current state

2. **Code Quality**
   - [ ] Docstrings updated for modified functions/classes
   - [ ] Type hints present and accurate
   - [ ] Tests added/updated for new functionality
   - [ ] All imports tested and working

3. **Version Control**
   - [ ] Conventional commit format used
   - [ ] All changes committed locally
   - [ ] Changes pushed to remote repository
   - [ ] Working tree clean

4. **User Engagement**
   - [ ] Clear next steps provided
   - [ ] User asked for input on priorities/direction
   - [ ] Context preserved for future sessions

### Communication Style Guidelines

1. **Be Comprehensive**: Show both the journey (real-time) and the destination (milestone)
2. **Use Technical Detail**: Include actual implementation specifics, not just summaries
3. **Maintain Engagement**: Ask questions and provide clear next steps
4. **Structure with Emojis**: Use consistent emoji patterns for visual organization
5. **Document Everything**: Every change must be reflected in relevant documentation
6. **Preserve Context**: Ensure future sessions can continue seamlessly
7. **Brutal Honesty with Constructive Intent**: Always provide honest, direct feedback about problems, limitations, and realistic assessments. Don't sugarcoat issues or provide false optimism. When something is broken, expensive, or impractical, say so clearly while offering constructive alternatives. The user values candid analysis over diplomatic evasion - this builds trust and enables better decision-making.

### Anti-Patterns to Avoid

‚ùå **Don't**: Provide only summary without technical detail  
‚úÖ **Do**: Show actual implementation work and architectural decisions

‚ùå **Don't**: Complete tasks without updating documentation  
‚úÖ **Do**: Update all relevant docs as part of task completion

‚ùå **Don't**: End responses without user engagement  
‚úÖ **Do**: Provide clear next steps and ask for direction

‚ùå **Don't**: Skip the comprehensive milestone documentation  
‚úÖ **Do**: Always provide both real-time narrative AND structured summary

Remember: Every task completion should feel like a mini-release with full documentation, testing, and user engagement. This creates a professional development experience and ensures nothing is ever lost or forgotten.

### Legacy Task Completion Reference

See `documentation.mdc` for the comprehensive documentation update checklist and decision tree.

## Rule Precedence

When rules conflict:
1. This master rule (README.mdc) takes highest precedence
2. `alwaysApply: true` rules override others
3. More specific glob patterns override general ones
4. Newer rules override older ones for the same scope

## Best Practices

1. **Consistency**: Follow established patterns unless changing them intentionally
2. **Documentation**: Every change should be documented
3. **Testing**: Every feature should be tested
4. **Communication**: Use clear commit messages and update all relevant docs
5. **Completeness**: Use the task completion checklist for EVERY task

## Quick Reference Commands

```bash
# After making changes, common commands:
poetry run black src/              # Format code
poetry run pytest                  # Run tests
poetry run pytest --cov=clipscribe # Check coverage
poetry check                       # Validate pyproject.toml
```

## CONTINUATION_PROMPT.md Format Requirements

### CRITICAL: Always Ask for Current Date/Time
Before updating CONTINUATION_PROMPT.md, ALWAYS run `date` command to get the current date.

### Required Format Template
```markdown
# ClipScribe AI Assistant Continuation Prompt

## Current State (YYYY-MM-DD HH:MM PDT)

### Latest Version: vX.X.X
[Brief summary of what this version includes]

### Recent Changes
- **vX.X.X** (YYYY-MM-DD): [What was done]
- [Keep last 3-5 versions]

### What's Working Well ‚úÖ
[List current working features with metrics]

### Known Issues ‚ö†Ô∏è
[Current bugs or limitations]

### Roadmap üó∫Ô∏è
- **Next**: [Immediate next task]
- **Soon**: [Next 2-3 priorities]
```

### Format Rules
1. **NEVER DELETE SECTIONS** - All sections must remain
2. **PRESERVE HISTORY** - Keep recent changes for context
3. **BE SPECIFIC** - Include version numbers, dates, metrics
4. **UPDATE DATE** - Always update the date in "Current State"
5. **KEEP CONCISE** - Each section should be 3-10 lines max
6. **USE CONSISTENT EMOJI** - ‚úÖ ‚ö†Ô∏è üöß üó∫Ô∏è only

Remember: This rule is the governance framework for the entire project. When in doubt, refer back to this document and ensure all checklist items are completed.

