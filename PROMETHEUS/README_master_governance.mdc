---
description: "Master governance rule that controls all other rules and ensures proper task completion with comprehensive communication protocols"
globs: []
alwaysApply: true
---
# Master Rules & Task Completion Guide

This is the central rule that governs all other rules and ensures proper task completion in your project.

## Template Instructions

**To Use This Template:**
1. Copy this file to `.cursor/rules/README.mdc` in your project
2. Replace `[PROJECT_NAME]` with your actual project name
3. Replace `[PROJECT_TYPE]` with your project type (web app, mobile app, library, etc.)
4. Update the available rules list with your actual rules
5. Customize the task completion checklist for your specific needs

## Rule Management

### Rule Format
Each `.mdc` file in `.cursor/rules/` follows this structure:

```yaml
---
description: "Brief description of the rule's purpose"
globs: ["**/*.py", "src/**/*.ts"]  # File patterns for auto-attachment
alwaysApply: false  # Whether the rule always applies
---

# Rule Content
```

### Available Rules Template

**Optimized Core Templates (5 Essential Rules):**
- `README.mdc` (this file) - Master rule governing all others, task completion protocols
- `core-identity.mdc` - Project mission, architecture, async patterns, data structures, configuration, error handling
- `api-patterns.mdc` - API integration, cost optimization, rate limiting, external service patterns  
- `documentation-standards.mdc` - Documentation standards, file organization, troubleshooting guides
- `testing-standards.mdc` - Testing requirements, quality standards, validation protocols

**Why Only 5 Templates?**
These 5 comprehensive templates provide complete coverage while avoiding choice paralysis:
- **Complete Coverage**: Every aspect of professional development is covered
- **Manageable**: Easy to customize and maintain
- **Comprehensive**: Each template is feature-rich and includes related patterns
- **Universal**: Works for any project type (web, CLI, library, mobile, data processing)

### How Rules Work
1. **Auto-attachment**: Rules with matching `globs` patterns automatically apply when working on those files
2. **Always Apply**: Rules with `alwaysApply: true` are active for all interactions
3. **Manual Reference**: You can reference any rule using `@rules/rule-name`

### Creating New Rules
When adding a new rule:
1. Use descriptive kebab-case filenames (e.g., `api-patterns.mdc`)
2. Include proper frontmatter with:
   - `description`: Brief explanation of what the rule covers
   - `globs`: File patterns where rule auto-applies (can be empty `[]`)
   - `alwaysApply`: true/false - whether rule is always active
3. Keep rules focused on a single concern
4. Include practical examples and code snippets
5. Use clear section headers and formatting
6. Add the rule to this README's Available Rules list

### When to Create Rules
Create a new rule when:
- You find yourself explaining the same pattern multiple times
- There's a specific convention unique to this project
- You want to document best practices for a component
- There are gotchas or non-obvious patterns to remember
- You need to ensure consistency across the codebase

### Updating Existing Rules
When modifying rules:
1. Preserve the frontmatter structure
2. Document why the change was made (in commit message)
3. Verify glob patterns still match intended files
4. Check for conflicts with other rules
5. Update any documentation that references the old behavior

## Task Completion Process

**CRITICAL: At the completion of EVERY task, follow the comprehensive communication and documentation update protocol.**

### Communication Template for Task Completion

**REQUIRED FORMAT: Combine real-time development narrative with comprehensive milestone documentation.**

#### Phase 1: Real-Time Development Narrative
During task execution, provide:
```markdown
**üéØ Development Order:**
1. **Component 1** (foundation/dependency reason)
2. **Component 2** (core functionality) 
3. **Component 3** (integration layer)

Let's start with **#1: Component Name** - explain why this is first.

[Show actual work being done with technical details]
- Read relevant files for context
- Implement specific changes with code snippets
- Explain technical decisions and architecture
- Document each step as it's completed

Perfect! Now I have Component 1 complete. Let's move to **#2: Component Name** - explain the dependency.

[Continue this pattern for each component]
```

#### Phase 2: Comprehensive Milestone Documentation
After completion, provide structured documentation:
```markdown
## ‚úÖ MAJOR MILESTONE ACHIEVED: [Task Name] Complete! üöÄ

### üéØ What Was Accomplished:

**1. Component Name** ‚úÖ
- Specific technical achievement 1
- Specific technical achievement 2  
- Performance/cost metrics if applicable

**2. Component Name** ‚úÖ
- Detailed implementation details
- Integration points and dependencies
- Quality improvements and optimizations

### üöÄ Key Achievements:
- **Architecture Impact**: How this changes the system
- **Performance Impact**: Metrics and improvements
- **Cost Impact**: Financial implications if relevant
- **User Impact**: How users benefit

### üìã Progress Status:
**‚úÖ COMPLETE** (X/Y components):
- List completed components

**üöß REMAINING** (Y-X components):
- List remaining work

### üìö Documentation Updates Completed:
- ‚úÖ **File 1**: What was updated and why
- ‚úÖ **File 2**: Specific changes made
- ‚úÖ **Version Control**: Commit and push status

### üöÄ Repository Status:
- ‚úÖ Local changes committed with conventional format
- ‚úÖ Remote repository synchronized  
- ‚úÖ Clean working tree

### üîÑ Next Steps/User Engagement:
Would you like me to proceed with [next logical component] to complete the [overall goal]?
```

#### Phase 3: Complete Task Checklist
**MANDATORY COMPLETION STEPS:**

1. **Documentation Updates** (see `documentation.mdc` for details)
   - [ ] CHANGELOG.md updated with current date
   - [ ] README.md updated if user-facing changes
   - [ ] [PROJECT_SPECIFIC_DOCS] updated if applicable
   - [ ] Version files updated if releasing
   - [ ] CONTINUATION_PROMPT.md updated with current state

2. **Code Quality**
   - [ ] Docstrings updated for modified functions/classes
   - [ ] Type hints present and accurate
   - [ ] Tests added/updated for new functionality
   - [ ] All imports tested and working

3. **Version Control**
   - [ ] Conventional commit format used
   - [ ] All changes committed locally
   - [ ] Changes pushed to remote repository
   - [ ] Working tree clean

4. **User Engagement**
   - [ ] Clear next steps provided
   - [ ] User asked for input on priorities/direction
   - [ ] Context preserved for future sessions

### Communication Style Guidelines

1. **Be Comprehensive**: Show both the journey (real-time) and the destination (milestone)
2. **Use Technical Detail**: Include actual implementation specifics, not just summaries
3. **Maintain Engagement**: Ask questions and provide clear next steps
4. **Structure with Emojis**: Use consistent emoji patterns for visual organization
5. **Document Everything**: Every change must be reflected in relevant documentation
6. **Preserve Context**: Ensure future sessions can continue seamlessly

### Anti-Patterns to Avoid

‚ùå **Don't**: Provide only summary without technical detail  
‚úÖ **Do**: Show actual implementation work and architectural decisions

‚ùå **Don't**: Complete tasks without updating documentation  
‚úÖ **Do**: Update all relevant docs as part of task completion

‚ùå **Don't**: End responses without user engagement  
‚úÖ **Do**: Provide clear next steps and ask for direction

‚ùå **Don't**: Skip the comprehensive milestone documentation  
‚úÖ **Do**: Always provide both real-time narrative AND structured summary

Remember: Every task completion should feel like a mini-release with full documentation, testing, and user engagement. This creates a professional development experience and ensures nothing is ever lost or forgotten.

## Rule Precedence

When rules conflict:
1. This master rule (README.mdc) takes highest precedence
2. `alwaysApply: true` rules override others
3. More specific glob patterns override general ones
4. Newer rules override older ones for the same scope

## Best Practices

1. **Consistency**: Follow established patterns unless changing them intentionally
2. **Documentation**: Every change should be documented
3. **Testing**: Every feature should be tested
4. **Communication**: Use clear commit messages and update all relevant docs
5. **Completeness**: Use the task completion checklist for EVERY task

## Quick Reference Commands

```bash
# Customize these for your project's tooling:
[BUILD_COMMAND]                    # Format code
[TEST_COMMAND]                     # Run tests
[COVERAGE_COMMAND]                 # Check coverage
[LINT_COMMAND]                     # Validate project files
```

## CONTINUATION_PROMPT.md Format Requirements

### CRITICAL: Always Ask for Current Date/Time
Before updating CONTINUATION_PROMPT.md, ALWAYS run `date` command to get the current date.

### Required Format Template
```markdown
# [PROJECT_NAME] AI Assistant Continuation Prompt

## Current State (YYYY-MM-DD HH:MM [TIMEZONE])

### Latest Version: vX.X.X
[Brief summary of what this version includes]

### Recent Changes
- **vX.X.X** (YYYY-MM-DD): [What was done]
- [Keep last 3-5 versions]

### What's Working Well ‚úÖ
[List current working features with metrics]

### Known Issues ‚ö†Ô∏è
[Current bugs or limitations]

### Roadmap üó∫Ô∏è
- **Next**: [Immediate next task]
- **Soon**: [Next 2-3 priorities]
```

### Format Rules
1. **NEVER DELETE SECTIONS** - All sections must remain
2. **PRESERVE HISTORY** - Keep recent changes for context
3. **BE SPECIFIC** - Include version numbers, dates, metrics
4. **UPDATE DATE** - Always update the date in "Current State"
5. **KEEP CONCISE** - Each section should be 3-10 lines max
6. **USE CONSISTENT EMOJI** - ‚úÖ ‚ö†Ô∏è üöß üó∫Ô∏è only

## Customization Notes

**To adapt this template for your project:**

1. **Replace placeholders**: Update all `[PROJECT_NAME]`, `[PROJECT_TYPE]`, etc.
2. **Customize rule categories**: Adjust the available rules list for your domain
3. **Update command references**: Replace with your actual build/test/lint commands
4. **Modify checklist items**: Add project-specific documentation requirements
5. **Adjust communication style**: Maintain the structure but adapt tone as needed

This template provides a complete governance framework that ensures consistent, professional development practices across any project type.

Remember: This rule is the governance framework for the entire project. When in doubt, refer back to this document and ensure all checklist items are completed.
